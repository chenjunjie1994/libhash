function evaRslt = CalcEvaRslt(dataMatLnk, codeMatDtb, codeMatQry, paraStr)
% INTRO
%   evaluate binary codes generated by the hashing model
% INPUT
%   dataMatLnk: K x N_Q (ground-truth matches)
%   codeMatDtb: R x N_D (binary codes of database samples)
%   codeMatQry: R x N_Q (binary codes of query samples)
%   paraStr: struct (hyper-parameters)
% OUTPUT
%   evaRslt: struct (evaluation results)

% add path for *.mexa64 files under ./mex
addpath('./mex');

% validate the evaluation protocol
assert(ismember(paraStr.evaPrtl, [{'HammRank'}, {'HashLkup'}]));

% obtain basic variables
smplCntDtb = size(codeMatDtb, 2);
smplCntQry = size(codeMatQry, 2);

% remove invalid evaluation positions
paraStr.evaPosLst = paraStr.evaPosLst(paraStr.evaPosLst <= smplCntDtb);

% convert -1/1 binary codes to {0, ..., 2 ^ n - 1} compact codes
codeMatDtb = mex_CvtHashToCompCode(uint8((codeMatDtb + 1) / 2));
codeMatQry = mex_CvtHashToCompCode(uint8((codeMatQry + 1) / 2));

% evaluate ANN search performance for each query
dataMatLnk = dataMatLnk + 1; % 0-based indexing to 1-based indexing
evaRslt = InitEvaRslt(paraStr);
for smplIdxQry = 1 : smplCntQry
  % display the heart-beat message
  if mod(smplIdxQry, 10) == 0
    fprintf('[INFO] evaluating query #%d\n', smplIdxQry);
  end
  
  % compute the precision/recall@T and meanAP scores
  distLst = mex_CalcHammDist(codeMatQry(:, smplIdxQry), codeMatDtb);
  linkLst = dataMatLnk(:, smplIdxQry);
  switch paraStr.evaPrtl
    case 'HammRank'
      evaRsltNew = EvaHammRank(...
          distLst, linkLst, paraStr.linkCntPerQry, paraStr.evaPosLst);
    case 'HashLkup'
      evaRsltNew = EvaHashLkup(...
          distLst, linkLst, paraStr.linkCntPerQry, paraStr.hashLkupRad);
  end
  evaRslt = UpdtEvaRslt(evaRslt, evaRsltNew, paraStr);
end

% display evaluation results
DispEvaRslt(evaRslt, paraStr);

end

function evaRslt = InitEvaRslt(paraStr)
% INTRO
%   initialize evaluation results
% INPUT
%   paraStr: struct (hyper-parameters)
% OUTPUT
%   evaRslt: struct (evaluation results)

% initialize a structure to store evaluation results
evaRslt.smplCntQry = 0; % # of evaluated queries
switch paraStr.evaPrtl
  case 'HammRank'
    evaPosCnt = numel(paraStr.evaPosLst);
    evaRslt.precMat = zeros(evaPosCnt, numel(paraStr.linkCntPerQry));
    evaRslt.reclMat = zeros(evaPosCnt, numel(paraStr.linkCntPerQry));
    evaRslt.mapVec = zeros(1, numel(paraStr.linkCntPerQry));
  case 'HashLkup'
    evaRslt.reclVec = zeros(1, numel(paraStr.linkCntPerQry));
end

end

function evaRslt = UpdtEvaRslt(evaRslt, evaRsltNew, paraStr)
% INTRO
%   update evaluation results
% INPUT
%   evaRslt: struct (overall evaluation results)
%   evaRsltNew: struct (single query's evaluation results)
%   paraStr: struct (hyper-parameters)
% OUTPUT
%   evaRslt: struct (overall evaluation results)

% update the structure of evaluation results
presRat = evaRslt.smplCntQry / (evaRslt.smplCntQry + 1); % preserving ratio
updtRat = 1 - presRat; % updating ratio
switch paraStr.evaPrtl
  case 'HammRank'
    evaRslt.precMat = presRat * evaRslt.precMat + updtRat * evaRsltNew.precMat;
    evaRslt.reclMat = presRat * evaRslt.reclMat + updtRat * evaRsltNew.reclMat;
    evaRslt.mapVec = presRat * evaRslt.mapVec + updtRat * evaRsltNew.mapVec;
  case 'HashLkup'
    evaRslt.reclVec = presRat * evaRslt.reclVec + updtRat * evaRsltNew.reclVec;
end
evaRslt.smplCntQry = evaRslt.smplCntQry + 1;

end

function DispEvaRslt(evaRslt, paraStr)
% INTRO
%   display evaluation results
% INPUT
%   evaRslt: struct (evaluation results)
%   paraStr: struct (hyper-parameters)
% OUTPUT
%   none

% display evaluation results
evaPosCnt = numel(paraStr.evaPosLst);
switch paraStr.evaPrtl
  case 'HammRank'
    frmtStr = repmat(' %f', [1, evaPosCnt]);
    for idx = 1 : numel(paraStr.linkCntPerQry)
      fprintf('[INFO] # of GT-matches: %d\n', paraStr.linkCntPerQry(idx));
      fprintf(['[INFO] precis@T =', frmtStr, '\n'], evaRslt.precMat(:, idx)');
      fprintf(['[INFO] recall@T =', frmtStr, '\n'], evaRslt.reclMat(:, idx)');
      fprintf('[INFO] meanAP = %f\n', evaRslt.mapVec(idx));
    end
  case 'HashLkup'
    for idx = 1 : numel(paraStr.linkCntPerQry)
      fprintf('[INFO] # of GT-matches: %d\n', paraStr.linkCntPerQry(idx));
      fprintf('[INFO] recall = %f\n', evaRslt.reclVec(idx));
    end
end

end
