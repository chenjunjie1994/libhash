function evaRslt = CalcEvaRslt(codeMatDtb, codeMatQry, paraStr, varargin)
% INTRO
%   evaluate binary codes generated by the hashing model
% INPUT
%   codeMatDtb: R x N_D (binary codes of database samples)
%   codeMatQry: R x N_Q (binary codes of query samples)
%   paraStr: struct (hyper-parameters)
%   varargin: cell array (GT-matches or category labels)
% OUTPUT
%   evaRslt: struct (evaluation results)

% add path for *.mexa64 files under ./mex
addpath('./mex');

% evaluate GT-matches or category labels
if numel(varargin) == 1
  linkMat = varargin{1};
else
  lablVecDtb = varargin{1};
  lablVecQry = varargin{2};
end

% validate the evaluation protocol
assert(ismember(paraStr.evaPrtl, [{'HammRank'}, {'HashLkup'}]));

% obtain basic variables
smplCntDtb = size(codeMatDtb, 2);
smplCntQry = size(codeMatQry, 2);

% remove invalid evaluation positions
paraStr.evaPosLst = paraStr.evaPosLst(paraStr.evaPosLst <= smplCntDtb);

% convert 0/1 binary codes to {0, ..., 2 ^ n - 1} compact codes
assert(isa(codeMatDtb, 'uint8') && isa(codeMatQry, 'uint8'));
codeMatDtb = mex_CvtHashToCompCode(codeMatDtb);
codeMatQry = mex_CvtHashToCompCode(codeMatQry);

% evaluate ANN search performance for each query
evaRslt = InitEvaRslt(paraStr);
for smplIdxQry = 1 : smplCntQry
  % display the heart-beat message
  if mod(smplIdxQry, 10) == 0
    fprintf('[INFO] evaluating query #%d\n', smplIdxQry);
  end
  
  % obtain the GT-matches for the current query
  if exist('linkMat', 'var')
    linkLst = linkMat(:, smplIdxQry);
  else
    linkLst = find(lablVecDtb == lablVecQry(smplIdxQry));
    paraStr.linkCntPerQry = numel(linkLst);
  end
  
  % override default values (-1) in <paraStr.linkCntPerQry>
  linkCntLst = paraStr.linkCntPerQry;
  linkCntLst(linkCntLst == -1) = numel(linkLst);
  
  % compute the precision/recall@T and meanAP scores
  distLst = mex_CalcHammDist(codeMatQry(:, smplIdxQry), codeMatDtb);
  switch paraStr.evaPrtl
    case 'HammRank'
      evaRsltNew = EvaHammRank(distLst, linkLst, linkCntLst, paraStr.evaPosLst);
    case 'HashLkup'
      evaRsltNew = EvaHashLkup(...
        distLst, linkLst, linkCntLst, paraStr.hashLkupRad);
  end
  evaRslt = UpdtEvaRslt(evaRslt, evaRsltNew, paraStr);
end

% display evaluation results
DispEvaRslt(evaRslt, paraStr);

end

function evaRslt = InitEvaRslt(paraStr)
% INTRO
%   initialize evaluation results
% INPUT
%   paraStr: struct (hyper-parameters)
% OUTPUT
%   evaRslt: struct (evaluation results)

% initialize a structure to store evaluation results
evaRslt.smplCntQry = 0; % # of evaluated queries
switch paraStr.evaPrtl
  case 'HammRank'
    evaPosCnt = numel(paraStr.evaPosLst);
    evaRslt.precMat = zeros(evaPosCnt, numel(paraStr.linkCntPerQry));
    evaRslt.reclMat = zeros(evaPosCnt, numel(paraStr.linkCntPerQry));
    evaRslt.mapVec = zeros(1, numel(paraStr.linkCntPerQry));
  case 'HashLkup'
    evaRslt.reclVec = zeros(1, numel(paraStr.linkCntPerQry));
end

end

function evaRslt = UpdtEvaRslt(evaRslt, evaRsltNew, paraStr)
% INTRO
%   update evaluation results
% INPUT
%   evaRslt: struct (overall evaluation results)
%   evaRsltNew: struct (single query's evaluation results)
%   paraStr: struct (hyper-parameters)
% OUTPUT
%   evaRslt: struct (overall evaluation results)

% update the structure of evaluation results
presRat = evaRslt.smplCntQry / (evaRslt.smplCntQry + 1); % preserving ratio
updtRat = 1 - presRat; % updating ratio
switch paraStr.evaPrtl
  case 'HammRank'
    evaRslt.precMat = presRat * evaRslt.precMat + updtRat * evaRsltNew.precMat;
    evaRslt.reclMat = presRat * evaRslt.reclMat + updtRat * evaRsltNew.reclMat;
    evaRslt.mapVec = presRat * evaRslt.mapVec + updtRat * evaRsltNew.mapVec;
  case 'HashLkup'
    evaRslt.reclVec = presRat * evaRslt.reclVec + updtRat * evaRsltNew.reclVec;
end
evaRslt.smplCntQry = evaRslt.smplCntQry + 1;

end

function DispEvaRslt(evaRslt, paraStr)
% INTRO
%   display evaluation results
% INPUT
%   evaRslt: struct (evaluation results)
%   paraStr: struct (hyper-parameters)
% OUTPUT
%   none

% display evaluation results
evaPosCnt = numel(paraStr.evaPosLst);
switch paraStr.evaPrtl
  case 'HammRank'
    frmtStr = repmat(' %f', [1, evaPosCnt]);
    for idx = 1 : numel(paraStr.linkCntPerQry)
      fprintf('[INFO] # of GT-matches: %d\n', paraStr.linkCntPerQry(idx));
      fprintf(['[INFO] precis@T =', frmtStr, '\n'], evaRslt.precMat(:, idx)');
      fprintf(['[INFO] recall@T =', frmtStr, '\n'], evaRslt.reclMat(:, idx)');
      fprintf('[INFO] meanAP = %f\n', evaRslt.mapVec(idx));
    end
  case 'HashLkup'
    for idx = 1 : numel(paraStr.linkCntPerQry)
      fprintf('[INFO] # of GT-matches: %d\n', paraStr.linkCntPerQry(idx));
      fprintf('[INFO] recall = %f\n', evaRslt.reclVec(idx));
    end
end

end
